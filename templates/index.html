<!DOCTYPE html>
<html lang="it">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Chat LLM</title>
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
        <style>
            #chat {
                max-height: 400px;
                overflow-y: auto;
                padding: 0;
                margin-bottom: 1rem;
                list-style: none;
            }
            .msg-human {
                text-align: right;
            }
            .msg-human .msg-bubble {
                display: inline-block;
                background: #0d6efd;
                color: #fff;
                border-radius: 15px 15px 0 15px;
                padding: 8px 14px;
                margin: 4px 0;
                max-width: 75%;
            }
            .msg-ai {
                text-align: left;
            }
            .msg-ai .msg-bubble {
                display: inline-block;
                background: #f1f1f1;
                color: #222;
                border-radius: 15px 15px 15px 0;
                padding: 8px 14px;
                margin: 4px 0;
                max-width: 75%;
            }
            .chat-card {
                margin-top: 40px;
                box-shadow: 0 2px 12px rgba(0,0,0,0.08);
            }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="card chat-card">
                <div class="card-header bg-primary text-white">
                    <b>Chat LLM</b>
                </div>
                <div class="card-body" style="background:#fafbfc;">
                    <ul id="chat">
                        {% for message in history %}
                        <li class="msg-{{ 'human' if message[0]=='human' else 'ai' }}">
                            <span class="msg-bubble"><b>{{ message[0] }}:</b> {{ message[1] }}</span>
                        </li>
                        {% endfor %}
                    </ul>
                    <div class="input-group">
                        <input type="text" class="form-control" id="message" placeholder="Scrivi un messaggio..." autocomplete="off">
                        <button id="record-btn" type="button" class="btn btn-outline-danger" onclick="toggleRecording()">
                            <span id="record-indicator" style="display:none;margin-right:6px;">●</span>Registra
                        </button>
                        <button id="send-message" type="button" onclick="sendMessage()" class="btn btn-primary">
                            <span class="spinner-border spinner-border-sm" id="btn-spinner" role="status" aria-hidden="true"></span>
                            Invia
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <script>
            document.getElementById("btn-spinner").style.display = 'none';

            // Scroll to bottom helper
            function scrollChatToBottom() {
                const chat = document.getElementById('chat');
                chat.scrollTop = chat.scrollHeight;
            }
            scrollChatToBottom();

            // Send message on Enter
            document.getElementById("message").addEventListener("keydown", function(e) {
                if (e.key === "Enter" && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Record message
            let audioChunks = [];
            let recording = false;
            let mediaRecorder = null;
            let lastRecordedAudioBase64 = null; // base64 senza prefisso data:...

            async function toggleRecording() {
                const btn = document.getElementById('record-btn');
                const indicator = document.getElementById('record-indicator');
                if (recording) {
                    // stop
                    mediaRecorder.stop();
                    recording = false;
                    btn.classList.remove('btn-danger');
                    btn.classList.add('btn-outline-danger');
                    indicator.style.display = 'none';
                    btn.textContent = 'Registra';
                    return;
                }

                // start
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    mediaRecorder.ondataavailable = e => {
                        if (e.data && e.data.size > 0) audioChunks.push(e.data);
                    };
                    mediaRecorder.onstop = async () => {
                        const blob = new Blob(audioChunks, { type: audioChunks[0]?.type || 'audio/webm' });
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            const dataUrl = reader.result; // "data:audio/..;base64,AAAA..."
                            const base64 = dataUrl.split(',')[1] || null;
                            lastRecordedAudioBase64 = base64;
                        };
                        reader.readAsDataURL(blob);
                        // stop all tracks to free microphone
                        stream.getTracks().forEach(t => t.stop());
                    };
                    mediaRecorder.start();
                    recording = true;
                    btn.classList.remove('btn-outline-danger');
                    btn.classList.add('btn-danger');
                    indicator.style.display = 'inline-block';
                    btn.innerHTML = '<span id="record-indicator">●</span> Stop';
                } catch (err) {
                    console.error('Microfono non disponibile', err);
                    alert('Impossibile accedere al microfono.');
                }
            }

            async function sendMessage() {
                const input = document.getElementById("message");
                const btn = document.getElementById("send-message");
                const spinner = document.getElementById("btn-spinner");
                const chat = document.getElementById('chat');
                const message = input.value.trim();
                // allow sending if there's either text or a recorded audio
                if (!message && !lastRecordedAudioBase64) return;

                // if recording in progress, stop it before sending
                if (recording && mediaRecorder) {
                    mediaRecorder.stop();
                    // wait a short moment for onstop to process the blob
                    await new Promise(r => setTimeout(r, 300));
                    recording = false;
                    document.getElementById('record-btn').classList.remove('btn-danger');
                    document.getElementById('record-btn').classList.add('btn-outline-danger');
                    document.getElementById('record-indicator').style.display = 'none';
                    document.getElementById('record-btn').textContent = 'Registra';
                }

                input.disabled = true;
                btn.disabled = true;
                spinner.style.display = 'block';

                // Add user message
                chat.innerHTML += `<li class="msg-human"><span class="msg-bubble"><b>human:</b> ${message || '[audio]'}</span></li>`;
                scrollChatToBottom();

                input.value = "";

                try {
                    const payload = { message: message };
                    if (lastRecordedAudioBase64) {
                        payload.audio = lastRecordedAudioBase64;
                    }

                    const response = await fetch('aicompanion', {
                        method: "POST",
                        body: JSON.stringify(payload),
                        headers: {
                            'Accept': 'application/json',
                            'Content-Type': 'application/json'
                        },
                    });

                    const deserialized = await response.json();

                    chat.innerHTML += `<li class="msg-ai"><span class="msg-bubble"><b>ai:</b> ${deserialized.response}</span></li>`;
                    scrollChatToBottom();

                    const audio = new Audio('data:audio/wav;base64,' + deserialized.audio);
                    audio.play();
                    // clear last recorded audio after successful send
                    lastRecordedAudioBase64 = null;
                } catch (e) {
                    chat.innerHTML += `<li class="msg-ai"><span class="msg-bubble text-danger"><b>ai:</b> Errore di rete</span></li>`;
                    scrollChatToBottom();
                }

                input.disabled = false;
                btn.disabled = false;
                spinner.style.display = 'none';
                input.focus();
            }
        </script>
        
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>
    </body>
</html>